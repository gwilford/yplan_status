#!/opt/local/bin/perl -w;

use strict;

# MPV settle time
my $settle = 30;
my %pins = { 2, 3 };
my %child;

# MPV signals => GPIO pin levels => Y Plan state mapping
my %yplan = { 1 => 
		{ 1  => "1:0",
		  0  => "",
		},
	      0 =>
		{ 1 => "1:1",
		  0 => "0:1",
		},
	    }

# Child routine
sub spawn_handler {
	my $pin = @_[0];
	my $pid = fork();
	die unless defined $pid;
	if ($pid == 0) {
		# In the child
		#system("gpio $pin wfl...");
		sleep $settle;
		exit(0);
	}
	$child{$pid} = $pin;
}

sub pin_state {
	my ($pin, $ret) = @_;
	my $change = 0;
	
	# read both pins
	foreach my $pin (keys %pins) {
		my $new = chomp(`gpio $pin read`);
		if ($pins{$pin} != $new) {
			$change = 1;
			$pins{$pin} = $new;
		}
	}
	update_rrd() if $change;
}

sub update_rrd {	
	#pin 2 = white, pin 3 = grey
	if ($pins{2}) {
		if ($pins{3}) {
			# 1 1
			#rrdtool update --template hw:ch N:1:0
		} else {
			# 1 0
			# no-op
		}
	} else {
		if ($pins{3}) {
			# 0 1
			#rrdtool update --template hw:ch N:1:1
			
		} else {
			# 0 0
			#rrdtool update --template hw:ch N:0:1
		}
}

# Initialise pin_handlers
foreach my $pin (keys %pins) {
	# init pin_status
	#gpio $pin input
	#gpio $pin pull_up
	#$pins{$pin} = chomp(`gpio $pin read`);
	spawn_handler($pin);
}

while (1) {
	my $pid = wait();
	# a child has exited
	pin_state($child{$pid}, $?);
	delete($child{$pid}) or die "Unknown child exited: $pid";
	# replace terminated handler
	spawn_handler($pin);
}
