#!/opt/local/bin/perl -w

# Might need some gpio pins exported as root before running this program as pi
# Might also need gpio edge before wfi works
use strict;

my $cmd = "/usr/bin/rrdtool update --template hw:ch ";
# MPV / relay settle time and de-bounce
my $settle = 5;
# The WiringPi GPIO pins we are monitoring
my %pins = { 2, 3 }; #pin 2 = white wire, pin 3 = grey wire
# MPV signals => GPIO pin levels (%pins)
#             => Y Plan state bitmap (%yplan)
# '1' may indicate CH calling or boiler/pump status
my %yplan = { 0 => "N:0:1",
	      2 => "N:1:1",
	      3 => "N:1:0", };
my %child;

# Child routine
sub spawn_child {
	my $pin = $_[0];
	my $pid = fork();
	die unless defined $pid;
	if ($pid == 0) {
		# In the child
		my $ret = system("gpio wfi $pin both");
		sleep $settle unless $ret;
		exit($ret);
	}
	$child{$pid} = $pin;
}

sub pin_state {
	my ($pin, $ret) = @_;
	my $change = 0;
	
	# an edge event has occurred on at least one pin
	# read both pins
	foreach my $pin (keys %pins) {
		my $level = `gpio read $pin`;
		chomp($level);
		if ($pins{$pin} != $level) {
			$change = 1;
			$pins{$pin} = $level;
		}
	}
	update_rrd() if $change;
}

sub update_rrd {	
	my $idx = $pins{2} + $pins{3} << 1;
	return unless exists($yplan{$idx});
	system($cmd . $yplan{$idx});
}

# Initialise pin edge change detection
foreach my $pin (keys %pins) {
	# init pin_status
	system("gpio mode $pin in");
	system("gpio mode $pin up");
	$pins{$pin} = `gpio read $pin`;
	chomp($pins{$pin});
	spawn_child($pin);
}

while (1) {
	my $pid = wait();
	# a child has exited
	exists($child{$pid}) or die "Unknown child exited: $pid";
	$? == 0 or die "Child $pid died with returncode: $?";
	pin_state($child{$pid});
	# replace terminated handler
	spawn_child($child{$pid});
	delete($child{$pid});
}
